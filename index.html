<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hello WebXR AR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #enter-ar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            padding: 1em 2em;
            background: #1e90ff;
            color: white;
            border: none;
            border-radius: 0.5em;
            cursor: pointer;
            z-index: 10;
        }

        #unsupported {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            color: #fff;
            padding: 2em;
            border-radius: 1em;
            z-index: 99999;
            text-align: center;
            display: none;
        }
    </style>
</head>

<body>
    <button id="enter-ar">Enter AR</button>

    <div id="unsupported">AR not supported on this device/browser.</div>
    <script src="https://unpkg.com/three@0.134.0/build/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r169/three.min.js"></script>
    <script>
        let xrSession = null;
        let xrRefSpace = null;
        let xrViewerSpace = null;
        let xrHitTestSource = null;
        let renderer, scene, camera, cube, reticle;

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera();
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Add a red cube (will be placed on surface)
            const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            cube = new THREE.Mesh(geometry, material);
            cube.visible = false;
            scene.add(cube);

            // Add a reticle to show placement
            const ringGeo = new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI / 2);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            reticle = new THREE.Mesh(ringGeo, ringMat);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Lighting
            scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
        }

        async function onEnterAR() {
            if (!navigator.xr) {
                document.getElementById('unsupported').style.display = 'block';
                return;
            }
            xrSession = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test', 'local-floor']
            });
            renderer.xr.setSession(xrSession);

            xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
            xrViewerSpace = await xrSession.requestReferenceSpace('viewer');
            xrHitTestSource = await xrSession.requestHitTestSource({ space: xrViewerSpace });

            document.getElementById('enter-ar').style.display = 'none';

            renderer.setAnimationLoop(renderAR);

            xrSession.addEventListener('end', () => {
                document.getElementById('enter-ar').style.display = 'block';
                if (renderer.domElement.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                }
                xrHitTestSource = null;
                xrViewerSpace = null;
                xrRefSpace = null;
                xrSession = null;
            });

            renderer.domElement.addEventListener('click', () => {
                if (reticle.visible) {
                    cube.position.setFromMatrixPosition(reticle.matrix);
                    cube.visible = true;
                }
            });
        }

        function renderAR(timestamp, frame) {
            if (frame && xrHitTestSource && xrRefSpace) {
                const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const pose = hit.getPose(xrRefSpace);
                    if (pose) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                } else {
                    reticle.visible = false;
                }
            }
            renderer.render(scene, camera);
        }

        // Setup
        if (navigator.xr) {
            document.getElementById('enter-ar').addEventListener('click', () => {
                if (!renderer) initScene();
                onEnterAR();
            });
        } else {
            document.getElementById('unsupported').style.display = 'block';
            document.getElementById('enter-ar').style.display = 'none';
        }
    </script>
</body>

</html>